"use strict";
/// <reference path="../../typings/main.d.ts" />
var _ = require("underscore");
var xmlutil = require('./xmlutil');
var contentprovider = require('./contentprovider');
var ZSchema = require("z-schema");
var ValidationResult = (function () {
    function ValidationResult() {
    }
    return ValidationResult;
}());
exports.ValidationResult = ValidationResult;
var useLint = true;
var ErrorsCache = (function () {
    function ErrorsCache() {
        this.errors = {};
    }
    ErrorsCache.prototype.get = function (key) {
        return this.errors[key];
    };
    ErrorsCache.prototype.set = function (key, value) {
        this.errors[key] = value;
    };
    return ErrorsCache;
}());
var globalCache = new ErrorsCache();
var JSONSchemaObject = (function () {
    function JSONSchemaObject(schema, provider) {
        this.schema = schema;
        this.provider = provider;
        if (!schema || schema.trim().length == 0 || schema.trim().charAt(0) != '{') {
            throw new Error("Invalid JSON schema content");
        }
        var jsonSchemaObject;
        try {
            var jsonSchemaObject = JSON.parse(schema);
        }
        catch (err) {
            throw new Error("It is not JSON schema");
        }
        if (!jsonSchemaObject) {
            return;
        }
        try {
            var api = require('json-schema-compatibility');
            this.setupId(jsonSchemaObject, this.provider.contextPath());
            jsonSchemaObject = api.v4(jsonSchemaObject);
        }
        catch (e) {
            throw new Error('Can not parse schema' + schema);
        }
        delete jsonSchemaObject['$schema'];
        this.jsonSchema = jsonSchemaObject;
    }
    JSONSchemaObject.prototype.getType = function () {
        return "source.json";
    };
    JSONSchemaObject.prototype.validateObject = function (object) {
        //TODO Validation of objects
        //xmlutil(content);
        this.validate(JSON.stringify(object));
    };
    JSONSchemaObject.prototype.getMissingReferences = function (references, normalize) {
        var _this = this;
        if (normalize === void 0) { normalize = false; }
        var result = [];
        var validator = new ZSchema();
        references.forEach(function (references) { return validator.setRemoteReference(references.reference, references.content || {}); });
        validator.validateSchema(this.jsonSchema);
        var result = validator.getMissingRemoteReferences();
        return normalize ? result.map(function (reference) { return _this.provider.normalizePath(reference); }) : result;
    };
    JSONSchemaObject.prototype.contentAsync = function (reference) {
        var _this = this;
        var remoteSchemeContent;
        var api = require('json-schema-compatibility');
        var contentPromise = this.provider.contentAsync(reference);
        if (!contentPromise) {
            return Promise.resolve({
                reference: reference,
                content: null,
                error: new Error('Reference not found: ' + reference)
            });
        }
        var result = contentPromise.then(function (cnt) {
            var content = { reference: reference };
            try {
                var jsonObject = JSON.parse(cnt);
                _this.setupId(jsonObject, _this.provider.normalizePath(reference));
                remoteSchemeContent = api.v4(jsonObject);
                delete remoteSchemeContent['$schema'];
                content.content = remoteSchemeContent;
            }
            catch (exception) {
                content.error = exception;
            }
            return content;
        });
        return result;
    };
    JSONSchemaObject.prototype.getSchemaPath = function (schema, normalize) {
        if (normalize === void 0) { normalize = false; }
        if (!schema) {
            return "";
        }
        if (!schema.id) {
            return "";
        }
        var id = schema.id.trim();
        if (!(id.lastIndexOf('#') === id.length - 1)) {
            return id;
        }
        var result = id.substr(0, id.length - 1);
        if (!normalize) {
            return result;
        }
        return this.provider.normalizePath(result);
    };
    JSONSchemaObject.prototype.patchSchema = function (schema) {
        var _this = this;
        if (!schema) {
            return schema;
        }
        if (!schema.id) {
            return schema;
        }
        var id = schema.id.trim();
        if (!(id.lastIndexOf('#') === id.length - 1)) {
            return schema;
        }
        ;
        var currentPath = id.substr(0, id.length - 1);
        if (!this.provider.isAbsolutePath(currentPath)) {
            return schema;
        }
        currentPath = this.provider.normalizePath(currentPath);
        var refContainers = [];
        this.collectRefContainers(schema, refContainers);
        refContainers.forEach(function (refConatiner) {
            var reference = refConatiner['$ref'];
            if (typeof reference !== 'string') {
                return;
            }
            if (reference.indexOf('#') === 0) {
                return;
            }
            if (!_this.provider.isAbsolutePath(reference)) {
                refConatiner['$ref'] = _this.provider.resolvePath(currentPath, reference).replace(/\\/g, '/');
            }
        });
    };
    JSONSchemaObject.prototype.collectRefContainers = function (rootObject, refContainers) {
        var _this = this;
        Object.keys(rootObject).forEach(function (key) {
            if (key === '$ref') {
                refContainers.push(rootObject);
                return;
            }
            if (!rootObject[key]) {
                return;
            }
            if (typeof rootObject[key] === 'object') {
                _this.collectRefContainers(rootObject[key], refContainers);
            }
        });
    };
    JSONSchemaObject.prototype.validate = function (content, alreadyAccepted) {
        var _this = this;
        if (alreadyAccepted === void 0) { alreadyAccepted = []; }
        var key = content + this.schema + this.provider.contextPath();
        var error = globalCache.get(key);
        if (error) {
            if (error instanceof Error) {
                throw error;
            }
            return;
        }
        var validator = new ZSchema();
        alreadyAccepted.forEach(function (accepted) { return validator.setRemoteReference(accepted.reference, accepted.content); });
        validator.validate(JSON.parse(content), this.jsonSchema);
        var missingReferences = validator.getMissingRemoteReferences().filter(function (reference) { return !_.find(alreadyAccepted, function (acceptedReference) { return reference === acceptedReference.reference; }); });
        if (!missingReferences || missingReferences.length === 0) {
            this.acceptErrors(key, validator.getLastErrors(), true);
            return;
        }
        var acceptedReferences = [];
        missingReferences.forEach(function (reference) {
            var remoteSchemeContent;
            var result = { reference: reference };
            try {
                var api = require('json-schema-compatibility');
                var jsonObject = JSON.parse(_this.provider.content(reference));
                _this.setupId(jsonObject, _this.provider.normalizePath(reference));
                remoteSchemeContent = api.v4(jsonObject);
                delete remoteSchemeContent['$schema'];
                result.content = remoteSchemeContent;
            }
            catch (exception) {
                result.error = exception;
            }
            finally {
                acceptedReferences.push(result);
            }
        });
        if (this.provider.hasAsyncRequests()) {
            return;
        }
        acceptedReferences.forEach(function (accepted) {
            alreadyAccepted.push(accepted);
        });
        this.validate(content, alreadyAccepted);
    };
    JSONSchemaObject.prototype.setupId = function (json, path) {
        if (!path) {
            return;
        }
        if (!json) {
            return;
        }
        if (!json.id) {
            json.id = path.replace(/\\/g, '/') + '#';
        }
        this.patchSchema(json);
    };
    JSONSchemaObject.prototype.acceptErrors = function (key, errors, throwImmediately) {
        if (throwImmediately === void 0) { throwImmediately = false; }
        if (errors && errors.length > 0) {
            var res = new Error("Content is not valid according to schema:" + errors.map(function (x) { return x.message + " " + x.params; }).join(", "));
            res.errors = errors;
            globalCache.set(key, res);
            if (throwImmediately) {
                throw res;
            }
            return;
        }
        globalCache.set(key, 1);
    };
    return JSONSchemaObject;
}());
exports.JSONSchemaObject = JSONSchemaObject;
var XMLSchemaObject = (function () {
    function XMLSchemaObject(schema) {
        this.schema = schema;
        if (schema.charAt(0) != '<') {
            throw new Error("Invalid JSON schema");
        }
        xmlutil(schema);
    }
    XMLSchemaObject.prototype.getType = function () {
        return "text.xml";
    };
    XMLSchemaObject.prototype.validate = function (content) {
        xmlutil(content);
    };
    XMLSchemaObject.prototype.validateObject = function (object) {
        //TODO Validation of objects
        //xmlutil(content);
    };
    return XMLSchemaObject;
}());
exports.XMLSchemaObject = XMLSchemaObject;
function getJSONSchema(content, provider) {
    var rs = useLint ? globalCache.get(content) : false;
    if (rs && rs.provider) {
        return rs;
    }
    var res = new JSONSchemaObject(content, provider);
    globalCache.set(content, res);
    return res;
}
exports.getJSONSchema = getJSONSchema;
function getXMLSchema(content) {
    var rs = useLint ? globalCache.get(content) : false;
    if (rs) {
        return rs;
    }
    var res = new XMLSchemaObject(content);
    if (useLint) {
        globalCache.set(content, res);
    }
}
exports.getXMLSchema = getXMLSchema;
function createSchema(content, provider) {
    var rs = useLint ? globalCache.get(content) : false;
    if (rs) {
        return rs;
    }
    try {
        var res = new JSONSchemaObject(content, provider);
        if (useLint) {
            globalCache.set(content, res);
        }
        return res;
    }
    catch (e) {
        try {
            var res = new XMLSchemaObject(content);
            if (useLint) {
                globalCache.set(content, res);
            }
            return res;
        }
        catch (e) {
            if (useLint) {
                globalCache.set(content, new Error("Can not parse schema"));
            }
            return null;
        }
    }
}
exports.createSchema = createSchema;
function isScheme(content) {
    try {
        var schemeObject = JSON.parse(content);
        return schemeObject['$schema'];
    }
    catch (exception) {
        return false;
    }
}
exports.isScheme = isScheme;
function startDownloadingReferencesAsync(schemaContent, unit) {
    var schemaObject = getJSONSchema(schemaContent, new contentprovider.ContentProvider(unit));
    var missedReferences = schemaObject.getMissingReferences([]).map(function (reference) { return schemaObject.contentAsync(reference); });
    if (missedReferences.length === 0) {
        return Promise.resolve(unit);
    }
    var allReferences = Promise.all(missedReferences);
    var result = getRefs(allReferences, schemaObject);
    return result.then(function () { return unit; });
}
exports.startDownloadingReferencesAsync = startDownloadingReferencesAsync;
function getReferences(schemaContent, unit) {
    var schemaObject = getJSONSchema(schemaContent, new contentprovider.ContentProvider(unit));
    return schemaObject.getMissingReferences([], true);
}
exports.getReferences = getReferences;
function getRefs(promise, schemaObject) {
    return promise.then(function (references) {
        if (references.length > 0) {
            var missedRefs = schemaObject.getMissingReferences(references);
            if (missedRefs.length === 0) {
                return [];
            }
            var promises = [];
            missedRefs.forEach(function (ref) {
                promises.push(schemaObject.contentAsync(ref));
            });
            return getRefs(Promise.all(promises.concat(references)), schemaObject);
        }
        return Promise.resolve([]);
    });
}
//# sourceMappingURL=schemaUtil.js.map