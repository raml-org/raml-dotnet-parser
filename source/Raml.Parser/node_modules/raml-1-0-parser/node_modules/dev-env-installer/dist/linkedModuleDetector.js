"use strict";
var fs = require("fs");
var path = require("path");
var _ = require("underscore");
function detectModulesInFolder(folder, modulesToDetect, parent) {
    var nodeModulesFolder = path.join(folder, "node_modules");
    if (!fs.existsSync(nodeModulesFolder))
        nodeModulesFolder = folder;
    subDirectories(nodeModulesFolder).forEach(function (subDirectory) {
        var fullSubdirPath = path.join(nodeModulesFolder, subDirectory);
        var subModule = moduleFromFolder(fullSubdirPath, modulesToDetect);
        if (subModule) {
            subModule.fsLocation = fs.realpathSync(fullSubdirPath);
            if (parent) {
                if (!parent.dependencies) {
                    parent.dependencies = [];
                }
                if (!_.find(parent.dependencies, function (dependency) { return dependency.name == subModule.name; })) {
                    parent.dependencies.push(subModule);
                }
            }
            detectModulesInFolder(fullSubdirPath, modulesToDetect, subModule);
        }
    });
}
function getModules(rootFolder, workspaceDescriptorFile) {
    var result = [];
    var modulesMap = loadModulesStaticInfo(workspaceDescriptorFile);
    var rootModule = moduleFromFolder(rootFolder, modulesMap);
    if (rootModule) {
        rootModule.fsLocation = fs.realpathSync(rootFolder);
    }
    detectModulesInFolder(rootFolder, modulesMap, rootModule);
    Object.keys(modulesMap).forEach(function (moduleName) {
        result.push(modulesMap[moduleName]);
    });
    return result;
}
exports.getModules = getModules;
function moduleFromFolder(folder, modulesToDetect) {
    var moduleFolderName = path.basename(folder);
    var moduleName = getModuleName(folder);
    var module = null;
    if (moduleFolderName && modulesToDetect[moduleFolderName]) {
        module = modulesToDetect[moduleFolderName];
    }
    else if (moduleName && modulesToDetect[moduleName]) {
        module = modulesToDetect[moduleName];
    }
    return module;
}
exports.moduleFromFolder = moduleFromFolder;
function getModuleName(rootModulePath) {
    var packageJsonPath = path.join(rootModulePath, "package.json");
    if (!fs.existsSync(packageJsonPath))
        return null;
    var packageJsonContents = fs.readFileSync(packageJsonPath).toString();
    var config = JSON.parse(packageJsonContents);
    return config.name;
}
function subDirectories(folder) {
    return fs.readdirSync(folder).filter(function (childName) {
        return fs.statSync(path.join(folder, childName)).isDirectory();
    });
}
exports.subDirectories = subDirectories;
function loadModulesStaticInfo(workspaceDescriptor) {
    var modulesListContent = fs.readFileSync(workspaceDescriptor).toString();
    var list = JSON.parse(modulesListContent);
    var result = {};
    Object.keys(list).forEach(function (moduleName) {
        var obj = list[moduleName];
        var branch = null;
        if (obj.gitBranch) {
            branch = obj.gitBranch;
        }
        else if (typeof (obj.gitBranch) == "boolean") {
            branch = null;
        }
        else {
            branch = "master";
        }
        var module = {
            name: moduleName,
            buildCommand: obj.build,
            testCommand: obj.test,
            gitUrl: obj.gitUrl,
            gitBranch: branch,
            installTypings: (obj.installTypings ? obj.installTypings : false)
        };
        result[moduleName] = module;
    });
    return result;
}
exports.loadModulesStaticInfo = loadModulesStaticInfo;
//# sourceMappingURL=linkedModuleDetector.js.map