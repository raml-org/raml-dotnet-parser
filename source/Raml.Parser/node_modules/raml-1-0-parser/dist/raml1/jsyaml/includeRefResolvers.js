/// <reference path="../../../typings/main.d.ts" />
"use strict";
var _ = require("underscore");
var base64 = require('base64url');
/**
 * Gets pure include path portion from the complete include.
 * Does not include the reference part.
 * @param includeString
 */
function getIncludePath(includeString) {
    if (!includeString) {
        return includeString;
    }
    var index = includeString.indexOf("#");
    if (index == -1)
        return includeString;
    return includeString.substring(0, index);
}
exports.getIncludePath = getIncludePath;
/**
 * Gets reference portion of the include string and returns it as
 * an array of segments. Returns null of no reference is contained in the include.
 * @param includeString
 */
function getIncludeReference(includeString) {
    if (!includeString) {
        return null;
    }
    var index = includeString.indexOf("#");
    if (index == -1)
        return null;
    var referenceString = index == includeString.length - 1 ? "" : includeString.substring(index + 1, includeString.length);
    var segments = referenceString.split("/");
    if (segments.length == 0)
        return null;
    if (segments[0].trim() == "") {
        segments.splice(0, 1);
    }
    return new IncludeReferenceImpl(referenceString, getIncludePath(includeString), segments);
}
exports.getIncludeReference = getIncludeReference;
/**
 * Factory method returning all include reference resolvers, registered in the system.
 */
function getIncludeReferenceResolvers() {
    return [new JSONResolver()];
}
exports.getIncludeReferenceResolvers = getIncludeReferenceResolvers;
/**
 * Checks all resolvers, finds the suitable one, resolves the reference and returns the result
 * of resolving. Returns null if no suitable resolver is found or resolver itself fails to resolve.
 * @param includeString - complete include string
 * @param content - include contents
 */
function resolveContents(includeString, content) {
    if (!includeString) {
        return content;
    }
    var reference = getIncludeReference(includeString);
    if (!reference) {
        return content;
    }
    var includePath = getIncludePath(includeString);
    return resolve(includePath, reference, content).content;
}
exports.resolveContents = resolveContents;
/**
 * Checks all resolvers, finds the suitable one, resolves the reference and returns the result
 * of resolving. Returns null if no suitable resolver is found or resolver itself fails to resolve.
 * @param includePath
 * @param includeReference
 * @param content
 */
function resolve(includePath, includeReference, content) {
    var resolver = _.find(getIncludeReferenceResolvers(), function (currentResolver) { return currentResolver.isApplicable(includePath, content); });
    if (!resolver)
        return {
            content: content,
            validation: []
        };
    return resolver.resolveReference(content, includeReference);
}
exports.resolve = resolve;
function completeReference(includePath, includeReference, content) {
    if (!content) {
        return [];
    }
    var resolver = _.find(getIncludeReferenceResolvers(), function (currentResolver) { return currentResolver.isApplicable(includePath, content); });
    if (!resolver)
        return [];
    return resolver.completeReference(content, includeReference);
}
exports.completeReference = completeReference;
var IncludeReferenceImpl = (function () {
    function IncludeReferenceImpl(originalString, includePath, segments) {
        this.includePath = includePath;
        this.segments = segments;
        this.originalString = originalString;
    }
    IncludeReferenceImpl.prototype.getIncludePath = function () {
        return this.includePath;
    };
    IncludeReferenceImpl.prototype.getFragments = function () {
        return this.segments;
    };
    IncludeReferenceImpl.prototype.asString = function () {
        return this.originalString;
    };
    IncludeReferenceImpl.prototype.encodedName = function () {
        return base64(this.includePath + '/' + this.asString()) + '.json';
    };
    return IncludeReferenceImpl;
}());
var JSONResolver = (function () {
    function JSONResolver() {
    }
    JSONResolver.prototype.isApplicable = function (includePath, content) {
        return true;
    };
    JSONResolver.prototype.resolveReference = function (content, reference) {
        try {
            var resultJson = {};
            resultJson['$ref'] = reference.getIncludePath() + '#' + reference.asString();
            return {
                content: JSON.stringify(resultJson, null, 2),
                validation: []
            };
        }
        catch (Error) {
            console.log(Error);
        }
        return {
            content: content,
            validation: []
        };
    };
    JSONResolver.prototype.completeReference = function (content, reference) {
        try {
            var jsonRoot = JSON.parse(content);
            var fragments = reference.getFragments();
            if (!fragments || fragments.length == 0) {
                return this.getChildren(jsonRoot);
            }
            var currentJSON = jsonRoot;
            var emptyPrefixCompletion = reference.asString().lastIndexOf("/") == reference.asString().length - 1;
            var limit = emptyPrefixCompletion ? fragments.length : fragments.length - 1;
            for (var i = 0; i < fragments.length - 1; i++) {
                var fragment = fragments[i];
                currentJSON = this.findChild(currentJSON, fragment);
                if (!currentJSON) {
                    return [];
                }
            }
            if (emptyPrefixCompletion) {
                return this.getChildren(currentJSON);
            }
            else {
                var lastPrefix = fragments[fragments.length - 1];
                var result = [];
                this.getChildren(currentJSON).forEach(function (child) {
                    if (child.indexOf(lastPrefix) == 0) {
                        result.push(child);
                    }
                });
                return result;
            }
        }
        catch (Error) {
            console.log(Error);
        }
        return [];
    };
    JSONResolver.prototype.findChild = function (jsonObject, fragment) {
        var decoded = fragment.replace('~1', '/');
        decoded = fragment.replace('~0', '~');
        return jsonObject[decoded];
    };
    JSONResolver.prototype.getChildren = function (jsonObject) {
        return Object.keys(jsonObject);
    };
    return JSONResolver;
}());
//# sourceMappingURL=includeRefResolvers.js.map