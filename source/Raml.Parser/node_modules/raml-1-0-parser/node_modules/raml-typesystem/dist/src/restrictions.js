"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/// <reference path="../typings/main.d.ts" />
var ts = require("./typesystem");
var su = require("./schemaUtil");
var _ = require("underscore");
var typesystem_1 = require("./typesystem");
var typesystem_2 = require("./typesystem");
/**
 * this class is an abstract super type for every constraint that can select properties from objects
 */
var MatchesProperty = (function (_super) {
    __extends(MatchesProperty, _super);
    function MatchesProperty(_type) {
        _super.call(this);
        this._type = _type;
    }
    MatchesProperty.prototype.matches = function (s) {
        return false;
    };
    MatchesProperty.prototype.check = function (i, p) {
        throw new Error("Should be never called");
    };
    MatchesProperty.prototype.patchPath = function (p) {
        if (!p) {
            return { name: this.propId() };
        }
        else {
            var c = p;
            var r = null;
            var cp = null;
            while (c) {
                if (!r) {
                    r = { name: c.name };
                    cp = r;
                }
                else {
                    var news = { name: c.name };
                    cp.child = news;
                    c = c.child;
                    cp = news;
                }
            }
            r.child = { name: this.propId() };
            return r;
        }
    };
    MatchesProperty.prototype.validateProp = function (i, n, t, q) {
        var vl = i[n];
        if (vl !== null && vl !== undefined) {
            var st = t.validate(vl, true, false);
            if (!st.isOk()) {
                if (t.isUnknown() || t.isRecurrent()) {
                    var s = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "Validating instance against unknown type:" + t.name(), this);
                    s.setValidationPath(this.patchPath(q));
                    return s;
                }
                var s = new typesystem_2.Status(typesystem_2.Status.OK, 0, "", this);
                st.getErrors().forEach(function (x) { return s.addSubStatus(x); });
                s.setValidationPath(this.patchPath(q));
                return s;
            }
        }
        return ts.OK_STATUS;
    };
    MatchesProperty.prototype.validateSelf = function (registry) {
        if (this._type.isAnonymous()) {
            var st = this._type.validateType(registry);
            if (!st.isOk()) {
                var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "property " + this.propId() + " range type has error:" + st.getMessage(), this);
                p.setValidationPath({ name: this.propId() });
                return p;
            }
            return st;
        }
        if (this._type.isExternal()) {
            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "It is not allowed to use external types in property definitions", this);
            p.setValidationPath({ name: this.propId() });
            return p;
        }
        if (this._type.isSubTypeOf(ts.UNKNOWN) || this._type.isSubTypeOf(ts.RECURRENT)) {
            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "property " + this.propId() + " refers to unknown type " + this._type.name(), this);
            p.setValidationPath({ name: this.propId() });
            return p;
        }
        if (this._type.isUnion()) {
            var ui = _.find(this._type.typeFamily(), function (x) { return x.isSubTypeOf(ts.UNKNOWN); });
            if (ui) {
                var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "property " + this.propId() + " refers to unknown type " + ui.name(), this);
                p.setValidationPath({ name: this.propId() });
                return p;
            }
        }
        return ts.OK_STATUS;
    };
    return MatchesProperty;
}(ts.Constraint));
exports.MatchesProperty = MatchesProperty;
var MatchToSchema = (function (_super) {
    __extends(MatchToSchema, _super);
    function MatchToSchema(_value, provider) {
        _super.call(this);
        this._value = _value;
        this.provider = provider;
    }
    MatchToSchema.prototype.value = function () {
        return this._value;
    };
    MatchToSchema.prototype.check = function (i) {
        var so = null;
        var strVal = this.value();
        if (strVal.charAt(0) == "{") {
            try {
                so = su.getJSONSchema(strVal, this.provider);
            }
            catch (e) {
                return new ts.Status(ts.Status.ERROR, 0, "Incorrect schema :" + e.message, this);
            }
        }
        if (strVal.charAt(0) == "<") {
            try {
                so = su.getXMLSchema(strVal);
            }
            catch (e) {
                return ts.OK_STATUS;
            }
        }
        if (so) {
            try {
                so.validateObject(i);
            }
            catch (e) {
                if (e.message == "Cannot assign to read only property '__$validated' of object") {
                    return ts.OK_STATUS;
                }
                if (e.message == "Object.keys called on non-object") {
                    return ts.OK_STATUS;
                }
                return new ts.Status(ts.Status.ERROR, 0, "Example does not conform to schema:" + e.message, this);
            }
        }
        return ts.OK_STATUS;
    };
    MatchToSchema.prototype.facetName = function () {
        return "schema";
    };
    MatchToSchema.prototype.requiredType = function () {
        return ts.EXTERNAL;
    };
    return MatchToSchema;
}(ts.Constraint));
exports.MatchToSchema = MatchToSchema;
/**
 * this is a constraint which checks that object has no unknown properties if at has not additional properties
 */
var KnownPropertyRestriction = (function (_super) {
    __extends(KnownPropertyRestriction, _super);
    function KnownPropertyRestriction(_value) {
        _super.call(this);
        this._value = _value;
    }
    KnownPropertyRestriction.prototype.facetName = function () {
        return "closed";
    };
    KnownPropertyRestriction.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    KnownPropertyRestriction.prototype.value = function () {
        return true;
    };
    KnownPropertyRestriction.prototype.patchOwner = function (t) {
        this._owner = t;
    };
    KnownPropertyRestriction.prototype.check = function (i) {
        var _this = this;
        if (this._value) {
            if (i && typeof i == 'object') {
                var nm = {};
                Object.getOwnPropertyNames(i).forEach(function (n) { return nm[n] = true; });
                var mp = this.owner().knownProperties();
                Object.getOwnPropertyNames(i).forEach(function (p) {
                    mp.forEach(function (v) {
                        if (v.matches(p)) {
                            delete nm[p];
                        }
                    });
                });
                if (Object.keys(nm).length > 0 && mp.length > 0) {
                    var s = new ts.Status(ts.Status.OK, 0, "", this);
                    Object.keys(nm).forEach(function (x) {
                        var err = ts.error("Unknown property:" + x, _this);
                        err.setValidationPath({ name: x });
                        s.addSubStatus(err);
                    });
                    return s;
                }
            }
        }
        return ts.OK_STATUS;
    };
    KnownPropertyRestriction.prototype.composeWith = function (restriction) {
        if (!this._value) {
            return null;
        }
        if (restriction instanceof KnownPropertyRestriction) {
            var mm = restriction;
            if (_.isEqual(this.owner().propertySet(), mm.owner().propertySet())) {
                return mm;
            }
        }
        if (restriction instanceof HasProperty) {
            var ps = restriction;
            var name = ps.value();
            var allowedPropertySet = this.owner().propertySet();
            if (allowedPropertySet.indexOf(name) == -1) {
                return this.nothing(ps);
            }
        }
    };
    return KnownPropertyRestriction;
}(ts.Constraint));
exports.KnownPropertyRestriction = KnownPropertyRestriction;
/**
 * this constaint checks that object has a particular property
 */
var HasProperty = (function (_super) {
    __extends(HasProperty, _super);
    function HasProperty(name) {
        _super.call(this);
        this.name = name;
    }
    HasProperty.prototype.check = function (i) {
        if (i && typeof i == 'object' && !Array.isArray(i)) {
            if (i.hasOwnProperty(this.name)) {
                return ts.OK_STATUS;
            }
            return ts.error("Required property: " + this.name + " is missed", this);
        }
        return ts.OK_STATUS;
    };
    HasProperty.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    HasProperty.prototype.facetName = function () {
        return "hasProperty";
    };
    HasProperty.prototype.value = function () {
        return this.name;
    };
    HasProperty.prototype.composeWith = function (r) {
        if (r instanceof HasProperty) {
            var hp = r;
            if (hp.name === this.name) {
                return this;
            }
        }
        return null;
    };
    return HasProperty;
}(ts.Constraint));
exports.HasProperty = HasProperty;
/**
 * this constraint checks that property has a particular tyoe if exists
 */
var PropertyIs = (function (_super) {
    __extends(PropertyIs, _super);
    function PropertyIs(name, type) {
        _super.call(this, type);
        this.name = name;
        this.type = type;
    }
    PropertyIs.prototype.matches = function (s) {
        return s === this.name;
    };
    PropertyIs.prototype.check = function (i, p) {
        if (i && typeof i === "object") {
            if (i.hasOwnProperty(this.name)) {
                var st = this.validateProp(i, this.name, this.type, p);
                return st;
            }
        }
        return ts.OK_STATUS;
    };
    PropertyIs.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    PropertyIs.prototype.propId = function () {
        return this.name;
    };
    PropertyIs.prototype.propertyName = function () {
        return this.name;
    };
    PropertyIs.prototype.facetName = function () {
        return "propertyIs";
    };
    PropertyIs.prototype.value = function () {
        return this.type;
    };
    PropertyIs.prototype.composeWith = function (t) {
        if (t instanceof PropertyIs) {
            var pi = t;
            if (pi.name === this.name) {
                if (this.type.typeFamily().indexOf(pi.type) != -1) {
                    return pi;
                }
                if (pi.type.typeFamily().indexOf(this.type) != -1) {
                    return this;
                }
                var intersectionType = this.intersect(this.type, pi.type);
                try {
                    var is = intersectionType.checkConfluent();
                    if (!is.isOk()) {
                        var rc = is;
                        return rc.toRestriction();
                    }
                    return new PropertyIs(this.name, intersectionType);
                }
                finally {
                    this.release(intersectionType);
                }
            }
        }
        return null;
    };
    return PropertyIs;
}(MatchesProperty));
exports.PropertyIs = PropertyIs;
/**
 * this cosnstraint checks that map property values passes to particular type if exists
 */
var MapPropertyIs = (function (_super) {
    __extends(MapPropertyIs, _super);
    function MapPropertyIs(regexp, type) {
        _super.call(this, type);
        this.regexp = regexp;
        this.type = type;
    }
    MapPropertyIs.prototype.matches = function (s) {
        if (s.match(this.regexp)) {
            return true;
        }
        return false;
    };
    MapPropertyIs.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    MapPropertyIs.prototype.propId = function () {
        return '[' + this.regexp + ']';
    };
    MapPropertyIs.prototype.facetName = function () {
        return "mapPropertyIs";
    };
    MapPropertyIs.prototype.value = function () {
        return this.type;
    };
    MapPropertyIs.prototype.regexpValue = function () {
        return this.regexp;
    };
    MapPropertyIs.prototype.validateSelf = function (t) {
        var m = this.checkValue();
        if (m) {
            return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, m, this);
        }
        return _super.prototype.validateSelf.call(this, t);
    };
    MapPropertyIs.prototype.checkValue = function () {
        try {
            new RegExp(this.regexp);
        }
        catch (e) {
            return e.message;
        }
        return null;
    };
    MapPropertyIs.prototype.composeWith = function (t) {
        if (t instanceof MapPropertyIs) {
            var pi = t;
            if (pi.regexp === this.regexp) {
                if (this.type.typeFamily().indexOf(pi.type) != -1) {
                    return pi;
                }
                if (pi.type.typeFamily().indexOf(this.type) != -1) {
                    return this;
                }
                var intersectionType = this.intersect(this.type, pi.type);
                try {
                    var is = intersectionType.checkConfluent();
                    if (!is.isOk()) {
                        var rc = is;
                        return rc.toRestriction();
                    }
                    return new MapPropertyIs(this.regexp, intersectionType);
                }
                finally {
                    this.release(intersectionType);
                }
            }
        }
        return null;
    };
    MapPropertyIs.prototype.check = function (i, p) {
        var _this = this;
        if (i) {
            if (typeof i == 'object') {
                var rs = new ts.Status(ts.Status.OK, 0, "", this);
                Object.getOwnPropertyNames(i).forEach(function (n) {
                    if (n.match(_this.regexp)) {
                        var stat = _this.validateProp(i, n, _this.type, p);
                        if (!stat.isOk()) {
                            rs.addSubStatus(stat);
                        }
                    }
                });
                return rs;
            }
        }
        return ts.OK_STATUS;
    };
    return MapPropertyIs;
}(MatchesProperty));
exports.MapPropertyIs = MapPropertyIs;
/**
 * this constraint tests that additional property
 */
var AdditionalPropertyIs = (function (_super) {
    __extends(AdditionalPropertyIs, _super);
    function AdditionalPropertyIs(type) {
        _super.call(this, type);
        this.type = type;
    }
    AdditionalPropertyIs.prototype.matches = function (s) {
        return true;
    };
    AdditionalPropertyIs.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    AdditionalPropertyIs.prototype.propId = function () {
        return '[]';
    };
    AdditionalPropertyIs.prototype.facetName = function () {
        return "additionalProperties";
    };
    AdditionalPropertyIs.prototype.value = function () {
        return this.type;
    };
    AdditionalPropertyIs.prototype.match = function (n) {
        var all = this.owner().metaOfType(PropertyIs);
        var map = this.owner().metaOfType(MapPropertyIs);
        for (var i = 0; i < all.length; i++) {
            if (all[i].matches(n)) {
                return true;
            }
        }
        for (var i = 0; i < map.length; i++) {
            if (map[i].matches(n)) {
                return true;
            }
        }
        return false;
    };
    AdditionalPropertyIs.prototype.composeWith = function (t) {
        if (t instanceof AdditionalPropertyIs) {
            var pi = t;
            if (this.type.typeFamily().indexOf(pi.type) != -1) {
                return pi;
            }
            if (pi.type.typeFamily().indexOf(this.type) != -1) {
                return this;
            }
            var intersectionType = this.intersect(this.type, pi.type);
            try {
                var is = intersectionType.checkConfluent();
                if (!is.isOk()) {
                    var rc = is;
                    return rc.toRestriction();
                }
                return new AdditionalPropertyIs(intersectionType);
            }
            finally {
                this.release(intersectionType);
            }
        }
        return null;
    };
    AdditionalPropertyIs.prototype.check = function (i, p) {
        var _this = this;
        var t = this.type;
        var res = new ts.Status(ts.Status.OK, 0, "", this);
        if (i && typeof i === "object") {
            Object.getOwnPropertyNames(i).forEach(function (n) {
                if (!_this.match(n)) {
                    var stat = _this.validateProp(i, n, t, p);
                    if (!stat.isOk()) {
                        res.addSubStatus(stat);
                    }
                }
            });
        }
        return res;
    };
    return AdditionalPropertyIs;
}(MatchesProperty));
exports.AdditionalPropertyIs = AdditionalPropertyIs;
/**
 * common super type for a simple restrictions
 */
var FacetRestriction = (function (_super) {
    __extends(FacetRestriction, _super);
    function FacetRestriction() {
        _super.apply(this, arguments);
    }
    FacetRestriction.prototype.validateSelf = function (registry) {
        if (!this.owner().isSubTypeOf(this.requiredType())) {
            var rs = ts.error(this.facetName() + " facet can only be used with " + this.requiredType().name() + " types", this);
            rs.setValidationPath({ name: this.facetName() });
            return rs;
        }
        var m = this.checkValue();
        if (m) {
            var rs = ts.error(m, this);
            rs.setValidationPath({ name: this.facetName() });
            return rs;
        }
        return ts.OK_STATUS;
    };
    return FacetRestriction;
}(ts.Constraint));
exports.FacetRestriction = FacetRestriction;
function is_int(value) {
    if ((parseFloat(value) == parseInt(value)) && !isNaN(value)) {
        return true;
    }
    else {
        return false;
    }
}
/**
 * abstract super type for every min max restriction
 */
var MinMaxRestriction = (function (_super) {
    __extends(MinMaxRestriction, _super);
    function MinMaxRestriction(_facetName, _value, _max, _opposite, _requiredType, _isInt) {
        _super.call(this);
        this._facetName = _facetName;
        this._value = _value;
        this._max = _max;
        this._opposite = _opposite;
        this._requiredType = _requiredType;
        this._isInt = _isInt;
    }
    MinMaxRestriction.prototype.facetName = function () {
        return this._facetName;
    };
    MinMaxRestriction.prototype.isIntConstraint = function () {
        return this._isInt;
    };
    MinMaxRestriction.prototype.isMax = function () {
        return this._max;
    };
    MinMaxRestriction.prototype.value = function () {
        return this._value;
    };
    MinMaxRestriction.prototype.check = function (i) {
        var o = this.extractValue(i);
        if (typeof o == 'number') {
            if (this.isMax()) {
                if (this.value() < o) {
                    return this.createError();
                }
            }
            else {
                if (this.value() > o) {
                    return this.createError();
                }
            }
        }
        return ts.OK_STATUS;
    };
    MinMaxRestriction.prototype.createError = function () {
        return ts.error(this.toString(), this);
    };
    MinMaxRestriction.prototype.minValue = function () {
        if (this._isInt) {
            return 0;
        }
        return Number.NEGATIVE_INFINITY;
    };
    MinMaxRestriction.prototype.requiredType = function () {
        return this._requiredType;
    };
    MinMaxRestriction.prototype.checkValue = function () {
        if (typeof this._value != "number") {
            return this.facetName() + " should be a number";
        }
        if (this.isIntConstraint()) {
            if (!is_int(this.value())) {
                return this.facetName() + " should be a integer";
            }
        }
        if (this.value() < this.minValue()) {
            return this.facetName() + " should be at least " + this.minValue();
        }
    };
    MinMaxRestriction.prototype.composeWith = function (t) {
        if (t instanceof MinMaxRestriction) {
            var mx = t;
            if (mx.facetName() == this.facetName()) {
                if (mx.isMax() == this.isMax()) {
                    if (this.isMax()) {
                        if (this.value() < mx.value()) {
                            return mx;
                        }
                        else {
                            return this;
                        }
                    }
                    else {
                        if (this.value() > mx.value()) {
                            return mx;
                        }
                        else {
                            return this;
                        }
                    }
                }
            }
            if (mx.facetName() === this._opposite) {
                if (this.isMax()) {
                    if (mx.value() > this.value()) {
                        return this.nothing(t);
                    }
                }
                else {
                    if (mx.value() < this.value()) {
                        return this.nothing(t);
                    }
                }
            }
        }
        return null;
    };
    return MinMaxRestriction;
}(FacetRestriction));
exports.MinMaxRestriction = MinMaxRestriction;
/**
 * maximum  constraint
 */
var Maximum = (function (_super) {
    __extends(Maximum, _super);
    function Maximum(val) {
        _super.call(this, "maximum", val, true, "minimum", ts.NUMBER, false);
    }
    Maximum.prototype.extractValue = function (i) {
        return i;
    };
    Maximum.prototype.toString = function () {
        return "value should be not more then " + this.value();
    };
    return Maximum;
}(MinMaxRestriction));
exports.Maximum = Maximum;
/**
 * minimum constraint
 */
var Minimum = (function (_super) {
    __extends(Minimum, _super);
    function Minimum(val) {
        _super.call(this, "minimum", val, false, "maximum", ts.NUMBER, false);
    }
    Minimum.prototype.extractValue = function (i) {
        return i;
    };
    Minimum.prototype.toString = function () {
        return "value should be not less then " + this.value();
    };
    return Minimum;
}(MinMaxRestriction));
exports.Minimum = Minimum;
/**
 * max items cosntraint
 */
var MaxItems = (function (_super) {
    __extends(MaxItems, _super);
    function MaxItems(val) {
        _super.call(this, "maxItems", val, true, "minItems", ts.ARRAY, true);
    }
    MaxItems.prototype.extractValue = function (i) {
        if (Array.isArray(i)) {
            return i.length;
        }
    };
    MaxItems.prototype.toString = function () {
        return "array should have not more then " + this.value() + " items";
    };
    return MaxItems;
}(MinMaxRestriction));
exports.MaxItems = MaxItems;
/**
 * min items cosntraint
 */
var MinItems = (function (_super) {
    __extends(MinItems, _super);
    function MinItems(val) {
        _super.call(this, "minItems", val, false, "maxItems", ts.ARRAY, true);
    }
    MinItems.prototype.extractValue = function (i) {
        if (Array.isArray(i)) {
            return i.length;
        }
    };
    MinItems.prototype.toString = function () {
        return "array should have not less then " + this.value() + " items";
    };
    return MinItems;
}(MinMaxRestriction));
exports.MinItems = MinItems;
/**
 * max length
 */
var MaxLength = (function (_super) {
    __extends(MaxLength, _super);
    function MaxLength(val) {
        _super.call(this, "maxLength", val, true, "minLength", ts.STRING, true);
    }
    MaxLength.prototype.extractValue = function (i) {
        if (typeof i == 'string') {
            return i.length;
        }
        return 0;
    };
    MaxLength.prototype.toString = function () {
        return "string length should be not more then " + this.value();
    };
    return MaxLength;
}(MinMaxRestriction));
exports.MaxLength = MaxLength;
/**
 * min length
 */
var MinLength = (function (_super) {
    __extends(MinLength, _super);
    function MinLength(val) {
        _super.call(this, "minLength", val, false, "maxLength", ts.STRING, true);
    }
    MinLength.prototype.extractValue = function (i) {
        if (typeof i == 'string') {
            return i.length;
        }
        return 0;
    };
    MinLength.prototype.toString = function () {
        return "string length should be not less then " + this.value();
    };
    return MinLength;
}(MinMaxRestriction));
exports.MinLength = MinLength;
/**
 * max properties constraint
 */
var MaxProperties = (function (_super) {
    __extends(MaxProperties, _super);
    function MaxProperties(val) {
        _super.call(this, "maxProperties", val, true, "minProperties", ts.OBJECT, true);
    }
    MaxProperties.prototype.extractValue = function (i) {
        return Object.keys(i).length;
    };
    MaxProperties.prototype.toString = function () {
        return "object should have not more then " + this.value() + " properties";
    };
    return MaxProperties;
}(MinMaxRestriction));
exports.MaxProperties = MaxProperties;
/**
 * min properties constraint
 */
var MinProperties = (function (_super) {
    __extends(MinProperties, _super);
    function MinProperties(val) {
        _super.call(this, "minProperties", val, false, "maxProperties", ts.OBJECT, true);
    }
    MinProperties.prototype.extractValue = function (i) {
        return Object.keys(i).length;
    };
    MinProperties.prototype.toString = function () {
        return "object should have not less then " + this.value() + " properties";
    };
    return MinProperties;
}(MinMaxRestriction));
exports.MinProperties = MinProperties;
/**
 * unique items constraint
 */
var UniqueItems = (function (_super) {
    __extends(UniqueItems, _super);
    function UniqueItems(_value) {
        _super.call(this);
        this._value = _value;
    }
    UniqueItems.prototype.facetName = function () { return "uniqueItems"; };
    UniqueItems.prototype.requiredType = function () { return ts.ARRAY; };
    UniqueItems.prototype.check = function (i) {
        if (Array.isArray(i)) {
            var r = i;
            if (_.unique(r).length != r.length) {
                return ts.error(this.toString(), this);
            }
        }
        return ts.OK_STATUS;
    };
    UniqueItems.prototype.composeWith = function (r) {
        if (r instanceof UniqueItems) {
            var mm = r;
            if (mm._value == this._value) {
                return this;
            }
        }
        return null;
    };
    UniqueItems.prototype.value = function () {
        return this._value;
    };
    UniqueItems.prototype.checkValue = function () {
        return null;
    };
    UniqueItems.prototype.toString = function () {
        return "items should be unique";
    };
    return UniqueItems;
}(FacetRestriction));
exports.UniqueItems = UniqueItems;
/**
 * components of array should be of type
 */
var ComponentShouldBeOfType = (function (_super) {
    __extends(ComponentShouldBeOfType, _super);
    function ComponentShouldBeOfType(type) {
        _super.call(this);
        this.type = type;
    }
    ComponentShouldBeOfType.prototype.facetName = function () { return "items"; };
    ComponentShouldBeOfType.prototype.requiredType = function () { return ts.ARRAY; };
    ComponentShouldBeOfType.prototype.toString = function () {
        return "items should be of type " + this.type;
    };
    ComponentShouldBeOfType.prototype.check = function (i) {
        var rs = new ts.Status(ts.Status.OK, 0, "", this);
        if (Array.isArray(i)) {
            var ar = i;
            for (var j = 0; j < ar.length; j++) {
                var ss = this.type.validate(ar[j], true);
                ss.setValidationPath({ name: "" + j });
                rs.addSubStatus(ss);
            }
        }
        return rs;
    };
    ComponentShouldBeOfType.prototype.validateSelf = function (registry) {
        if (this.type.isAnonymous()) {
            var st = this.type.validateType(registry);
            if (!st.isOk()) {
                return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "component type has error:" + st.getMessage(), this);
            }
            return st;
        }
        if (this.type.isExternal()) {
            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "It is not allowed to use external types in component type definitions", this);
            return p;
        }
        if (this.type.isSubTypeOf(ts.UNKNOWN) || this.type.isSubTypeOf(ts.RECURRENT)) {
            return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "component refers to unknown type " + this.type.name(), this);
        }
        if (this.type.isUnion()) {
            var ui = _.find(this.type.typeFamily(), function (x) { return x.isSubTypeOf(ts.UNKNOWN); });
            if (ui) {
                return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "component refers to unknown type " + ui.name(), this);
            }
        }
        return ts.OK_STATUS;
    };
    ComponentShouldBeOfType.prototype.composeWith = function (t) {
        if (t instanceof ComponentShouldBeOfType) {
            var pi = t;
            if (this.type.typeFamily().indexOf(pi.type) != -1) {
                return pi;
            }
            if (pi.type.typeFamily().indexOf(this.type) != -1) {
                return this;
            }
            var intersectionType = this.intersect(this.type, pi.type);
            try {
                var is = intersectionType.checkConfluent();
                if (!is.isOk()) {
                    var rc = is;
                    return rc.toRestriction();
                }
                return new ComponentShouldBeOfType(intersectionType);
            }
            finally {
                this.release(intersectionType);
            }
        }
        return null;
    };
    ComponentShouldBeOfType.prototype.checkValue = function () {
        return null;
    };
    ComponentShouldBeOfType.prototype.value = function () {
        return this.type;
    };
    return ComponentShouldBeOfType;
}(FacetRestriction));
exports.ComponentShouldBeOfType = ComponentShouldBeOfType;
/**
 * regular expression (pattern) constraint
 */
var Pattern = (function (_super) {
    __extends(Pattern, _super);
    function Pattern(_value) {
        _super.call(this);
        this._value = _value;
    }
    Pattern.prototype.facetName = function () { return "pattern"; };
    Pattern.prototype.requiredType = function () { return ts.STRING; };
    Pattern.prototype.check = function (i) {
        if (typeof i == 'string') {
            var st = i;
            try {
                var mm = st.match(this._value);
                if (!mm) {
                    return new ts.Status(ts.Status.ERROR, 0, "string should match to " + this.value(), this);
                }
            }
            catch (e) {
            }
        }
        return ts.OK_STATUS;
    };
    Pattern.prototype.composeWith = function (r) {
        if (r instanceof Pattern) {
            var v = r;
            if (v._value === this._value) {
                return this;
            }
            return this.nothing(r, "pattern restrictions can not be composed at one type");
        }
        return null;
    };
    Pattern.prototype.value = function () {
        return this._value;
    };
    Pattern.prototype.checkValue = function () {
        try {
            new RegExp(this._value);
        }
        catch (e) {
            return e.message;
        }
        return null;
    };
    Pattern.prototype.toString = function () {
        return "should pass reg exp:" + this.value;
    };
    return Pattern;
}(FacetRestriction));
exports.Pattern = Pattern;
/**
 * enum constraint
 */
var Enum = (function (_super) {
    __extends(Enum, _super);
    function Enum(_value) {
        _super.call(this);
        this._value = _value;
        if (!Array.isArray(_value)) {
            this._value = [_value];
        }
    }
    Enum.prototype.facetName = function () { return "enum"; };
    Enum.prototype.requiredType = function () { return ts.SCALAR; };
    Enum.prototype.check = function (i) {
        if (!this.checkStatus) {
            if (!this.value().some(function (x) { return x == i; })) {
                return ts.error(this.toString(), this);
            }
        }
        return ts.OK_STATUS;
    };
    Enum.prototype.composeWith = function (r) {
        if (r instanceof Enum) {
            var v = r;
            var sss = _.intersection(this._value, v._value);
            if (sss.length == 0) {
                return this.nothing(r);
            }
            return new Enum(sss);
        }
        return null;
    };
    Enum.prototype.value = function () {
        return this._value;
    };
    Enum.prototype.checkValue = function () {
        var _this = this;
        if (!this.owner().isSubTypeOf(this.requiredType())) {
            return "enum facet can only be used with: " + this.requiredType().name();
        }
        if (_.uniq(this._value).length < this._value.length) {
            return "enum facet can only contain unique items";
        }
        var result = null;
        this.checkStatus = true;
        try {
            this._value.forEach(function (x) {
                var res = _this.owner().validate(x);
                if (!res.isOk()) {
                    result = res.getMessage();
                }
            });
        }
        finally {
            this.checkStatus = false;
        }
        return result;
    };
    Enum.prototype.toString = function () {
        return "value should be one of:" + this._value;
    };
    return Enum;
}(FacetRestriction));
exports.Enum = Enum;
/**
 * this function attempts to optimize to set of restrictions
 * @param r
 * @returns {ts.Constraint[]}
 */
function optimize(r) {
    r = r.map(function (x) { return x.preoptimize(); });
    var optimized = [];
    r.forEach(function (x) {
        if (x instanceof typesystem_1.AndRestriction) {
            var ar = x;
            ar.options().forEach(function (y) { optimized.push(y); });
        }
        else {
            optimized.push(x);
        }
    });
    var transformed = true;
    while (transformed) {
        transformed = false;
        for (var i = 0; i < optimized.length; i++) {
            for (var j = 0; j < optimized.length; j++) {
                var rs0 = optimized[i];
                var rs1 = optimized[j];
                if (rs0 !== rs1) {
                    var compose = rs0.tryCompose(rs1);
                    if (compose) {
                        var newOptimized = optimized.filter(function (x) { return x !== rs0 && x !== rs1; });
                        newOptimized.push(compose);
                        transformed = true;
                        optimized = newOptimized;
                        break;
                    }
                }
            }
            if (transformed) {
                break;
            }
        }
    }
    return optimized;
}
exports.optimize = optimize;
//# sourceMappingURL=restrictions.js.map