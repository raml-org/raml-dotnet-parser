/// <reference path="../typings/main.d.ts" />
"use strict";
var raml_xml_validation_1 = require("raml-xml-validation");
var raml_xml_validation_2 = require("raml-xml-validation");
var _ = require("./utils");
var xmlUtil = require('./xmlUtil');
var jsonUtil = require('./jsonUtil');
var DOMParser = require('xmldom').DOMParser;
var ts = require("./typesystem");
var typesystem_1 = require("./typesystem");
var ValidationResult = (function () {
    function ValidationResult() {
    }
    return ValidationResult;
}());
exports.ValidationResult = ValidationResult;
var useLint = true;
var CACHE_SIZE_BARRIER = 5 * 1024 * 1024;
var ErrorsCache = (function () {
    function ErrorsCache() {
        this.errors = {};
        this.size = 0;
    }
    ErrorsCache.prototype.getValue = function (key) {
        var e = this.errors[key];
        if (!e) {
            return null;
        }
        return e.value;
    };
    ErrorsCache.prototype.setValue = function (key, value) {
        var e = this.errors[key];
        if (!e) {
            e = {
                key: key,
                value: value
            };
            if (this.top) {
                this.top.next = e;
            }
            this.top = e;
            if (!this.last) {
                this.last = e;
            }
            this.errors[key] = e;
            this.size += key.length;
            while (this.size > CACHE_SIZE_BARRIER) {
                if (!this.last) {
                    break;
                }
                var k = this.last.key;
                delete this.errors[k];
                this.size -= k.length;
                this.last = this.last.next;
            }
        }
        else {
            e.value = value;
        }
    };
    return ErrorsCache;
}());
var globalCache = new ErrorsCache();
global.cleanCache = function () {
    globalCache = new ErrorsCache();
};
var DummyProvider = (function () {
    function DummyProvider() {
    }
    DummyProvider.prototype.contextPath = function () {
        return "";
    };
    DummyProvider.prototype.normalizePath = function (url) {
        return "";
    };
    DummyProvider.prototype.content = function (reference) {
        return "";
    };
    DummyProvider.prototype.hasAsyncRequests = function () {
        return false;
    };
    DummyProvider.prototype.resolvePath = function (context, relativePath) {
        return "";
    };
    DummyProvider.prototype.isAbsolutePath = function (uri) {
        return false;
    };
    DummyProvider.prototype.contentAsync = function (reference) {
        var _this = this;
        return {
            then: function (arg) { return arg(_this.content(reference)); },
            resolve: function () { return null; }
        };
    };
    DummyProvider.prototype.promiseResolve = function (arg) {
        return {
            then: function (arg1) { return arg1(arg); },
            resolve: function () { return null; }
        };
    };
    return DummyProvider;
}());
var exampleKey = function (content, schema, contextPath) {
    return "__EXAMPLE_" + content + schema + contextPath;
};
var JSONSchemaObject = (function () {
    function JSONSchemaObject(schema, provider) {
        this.schema = schema;
        this.provider = provider;
        if (!provider) {
            this.provider = new DummyProvider();
        }
        else {
            this.provider = provider;
        }
        if (!schema || schema.trim().length == 0 || schema.trim().charAt(0) != '{') {
            throw new ts.ValidationError(typesystem_1.messageRegistry.INVALID_JSON_SCHEMA);
        }
        var jsonSchemaObject;
        try {
            var jsonSchemaObject = JSON.parse(schema);
        }
        catch (err) {
            throw new ts.ValidationError(typesystem_1.messageRegistry.INVALID_JSON_SCHEMA_DETAILS, { msg: err.message });
        }
        if (!jsonSchemaObject) {
            return;
        }
        try {
            var api = require('json-schema-compatibility');
            this.setupId(jsonSchemaObject, this.provider.contextPath());
            var schemaVer = "" + jsonSchemaObject["$schema"];
            if (schemaVer.indexOf("http://json-schema.org/draft-04/") == -1) {
                jsonSchemaObject = api.v4(jsonSchemaObject);
            }
            else {
                this.fixRequired(jsonSchemaObject);
            }
        }
        catch (e) {
            throw new ts.ValidationError(typesystem_1.messageRegistry.INVALID_JSON_SCHEMA_DETAILS, { msg: e.message });
        }
        delete jsonSchemaObject['$schema'];
        this.jsonSchema = jsonSchemaObject;
    }
    JSONSchemaObject.prototype.fixRequired = function (obj) {
        // Object.keys(obj).forEach(x=>{
        //     var val=obj[x];
        //     if (x==="required"){
        //         if (typeof val==="string"){
        //             obj[x]=[val];
        //         }
        //     }
        //     if (x==="properties"||x==="items"||x==="additionalItems"||x==="patternProperties"){
        //         this.fixRequired(val);
        //     }
        //
        // })
    };
    JSONSchemaObject.prototype.getType = function () {
        return "source.json";
    };
    JSONSchemaObject.prototype.validateObject = function (object) {
        //TODO Validation of objects
        //xmlutil(content);
        this.validate(JSON.stringify(object));
    };
    JSONSchemaObject.prototype.getMissingReferences = function (references, normalize) {
        var _this = this;
        if (normalize === void 0) { normalize = false; }
        var result = [];
        var validator = jsonUtil.getValidator();
        references.forEach(function (reference) { return validator.setRemoteReference(reference.reference, reference.content || {}); });
        var schemaUrl = null;
        if (this.jsonSchema.id && typeof (this.jsonSchema.id) === "string") {
            schemaUrl = this.jsonSchema.id;
            var innerPos = schemaUrl.indexOf("#");
            if (innerPos != -1) {
                schemaUrl = schemaUrl.substr(0, innerPos);
            }
        }
        try {
            validator.validateSchema(this.jsonSchema);
        }
        catch (Error) {
            //we should never be exploding here, instead we'll report this error later
            return [];
        }
        var result = validator.getMissingRemoteReferences();
        var filteredReferences = [];
        if (result)
            filteredReferences = _.filter(result, function (referenceUrl) {
                return !validator.isResourceLoaded(referenceUrl) && referenceUrl != schemaUrl;
            });
        return normalize ? filteredReferences.map(function (reference) { return _this.provider.normalizePath(reference); }) : filteredReferences;
    };
    JSONSchemaObject.prototype.getSchemaPath = function (schema, normalize) {
        if (normalize === void 0) { normalize = false; }
        if (!schema) {
            return "";
        }
        if (!schema.id) {
            return "";
        }
        var id = schema.id.trim();
        if (!(id.lastIndexOf('#') === id.length - 1)) {
            return id;
        }
        var result = id.substr(0, id.length - 1);
        if (!normalize) {
            return result;
        }
        return this.provider.normalizePath(result);
    };
    JSONSchemaObject.prototype.patchSchema = function (schema) {
        var _this = this;
        if (!schema) {
            return schema;
        }
        if (!schema.id) {
            return schema;
        }
        var id = schema.id.trim();
        if (!(id.lastIndexOf('#') === id.length - 1)) {
            id = id + '#';
            schema.id = id;
        }
        ;
        var currentPath = id.substr(0, id.length - 1);
        if (!this.provider.isAbsolutePath(currentPath)) {
            return schema;
        }
        currentPath = this.provider.normalizePath(currentPath);
        var refContainers = [];
        this.collectRefContainers(schema, refContainers);
        refContainers.forEach(function (refConatiner) {
            var reference = refConatiner['$ref'];
            if (typeof reference !== 'string') {
                return;
            }
            if (reference.indexOf('#') === 0) {
                return;
            }
            if (reference.indexOf('#') === -1) {
                reference = reference + '#';
            }
            var resolvedRef = _this.provider.resolvePath(currentPath, reference);
            refConatiner['$ref'] = resolvedRef;
        });
    };
    JSONSchemaObject.prototype.collectRefContainers = function (rootObject, refContainers) {
        var _this = this;
        Object.keys(rootObject).forEach(function (key) {
            if (key === '$ref') {
                refContainers.push(rootObject);
                return;
            }
            if (!rootObject[key]) {
                return;
            }
            if (typeof rootObject[key] === 'object') {
                _this.collectRefContainers(rootObject[key], refContainers);
            }
        });
    };
    JSONSchemaObject.prototype.validate = function (content, alreadyAccepted) {
        var _this = this;
        if (alreadyAccepted === void 0) { alreadyAccepted = []; }
        var key = exampleKey(content, this.schema, this.provider.contextPath());
        var error = globalCache.getValue(key);
        if (error) {
            if (error instanceof Error) {
                throw error;
            }
            return;
        }
        var validator = jsonUtil.getValidator();
        alreadyAccepted.forEach(function (accepted) { return validator.setRemoteReference(accepted.reference, accepted.content); });
        validator.validate(JSON.parse(content), this.jsonSchema);
        var missingReferences = validator.getMissingRemoteReferences().filter(function (reference) { return !_.find(alreadyAccepted, function (acceptedReference) { return reference === acceptedReference.reference; }); });
        if (!missingReferences || missingReferences.length === 0) {
            this.acceptErrors(key, validator.getLastErrors(), true);
            return;
        }
        var acceptedReferences = [];
        missingReferences.forEach(function (reference) {
            var remoteSchemeContent;
            var result = { reference: reference };
            try {
                var api = require('json-schema-compatibility');
                var jsonObject = JSON.parse(_this.provider.content(reference));
                _this.setupId(jsonObject, _this.provider.normalizePath(reference));
                remoteSchemeContent = api.v4(jsonObject);
                delete remoteSchemeContent['$schema'];
                result.content = remoteSchemeContent;
            }
            catch (exception) {
                result.error = exception;
            }
            finally {
                acceptedReferences.push(result);
            }
        });
        if (this.provider.hasAsyncRequests()) {
            return;
        }
        acceptedReferences.forEach(function (accepted) {
            alreadyAccepted.push(accepted);
        });
        this.validate(content, alreadyAccepted);
    };
    JSONSchemaObject.prototype.setupId = function (json, path) {
        if (!path) {
            return;
        }
        if (!json) {
            return;
        }
        if (json.id) {
            json.id = json.id.trim();
            if (json.id.indexOf('#') < 0) {
                json.id = json.id + '#';
            }
            return;
        }
        json.id = path.replace(/\\/g, '/') + '#';
        this.patchSchema(json);
    };
    JSONSchemaObject.prototype.acceptErrors = function (key, errors, throwImmediately) {
        if (throwImmediately === void 0) { throwImmediately = false; }
        if (errors && errors.length > 0) {
            var msg = errors.map(function (x) { return x.message + " " + x.params; }).join(", ");
            var res = new ts.ValidationError(typesystem_1.messageRegistry.CONTENT_DOES_NOT_MATCH_THE_SCHEMA, { msg: msg });
            res.errors = errors;
            globalCache.setValue(key, res);
            if (throwImmediately) {
                throw res;
            }
            return;
        }
        globalCache.setValue(key, 1);
    };
    JSONSchemaObject.prototype.contentAsync = function (reference) {
        var _this = this;
        var remoteSchemeContent;
        var api = require('json-schema-compatibility');
        var contentPromise = this.provider.contentAsync(reference);
        if (!contentPromise) {
            return this.provider.promiseResolve({
                reference: reference,
                content: null,
                error: new ts.ValidationError(typesystem_1.messageRegistry.REFERENCE_NOT_FOUND, { ref: reference })
            });
        }
        var result = contentPromise.then(function (cnt) {
            var content = { reference: reference };
            try {
                var jsonObject = JSON.parse(cnt);
                _this.setupId(jsonObject, _this.provider.normalizePath(reference));
                remoteSchemeContent = api.v4(jsonObject);
                delete remoteSchemeContent['$schema'];
                content.content = remoteSchemeContent;
            }
            catch (exception) {
                content.error = exception;
            }
            return content;
        });
        return result;
    };
    return JSONSchemaObject;
}());
exports.JSONSchemaObject = JSONSchemaObject;
var MAX_EXAMPLES_TRESHOLD = 10;
var XMLSchemaObject = (function () {
    function XMLSchemaObject(schema, provider) {
        this.schema = schema;
        this.provider = provider;
        this.extraElementData = null;
        this.references = {};
        this.contentToResult = {};
        if (!provider) {
            this.provider = new DummyProvider();
        }
        if (schema.charAt(0) != '<') {
            throw new ts.ValidationError(typesystem_1.messageRegistry.INVALID_XML_SCHEMA);
        }
        this.schemaString = this.handleReferenceElement(schema);
    }
    XMLSchemaObject.prototype.getType = function () {
        return "text.xml";
    };
    XMLSchemaObject.prototype.validateObject = function (object) {
        if (this.extraElementData) {
            var objectName = Object.keys(object)[0];
            var err = new ts.ValidationError(typesystem_1.messageRegistry.EXTERNAL_TYPE_ERROR, { typeName: this.extraElementData.requestedName, objectName: objectName });
            if (!this.extraElementData.type && !this.extraElementData.originalName) {
                this.acceptErrors("key", [err], true);
                return;
            }
            if (this.extraElementData.originalName && objectName !== this.extraElementData.originalName) {
                this.acceptErrors("key", [err], true);
                return;
            }
            if (this.extraElementData.type) {
                var root = object[objectName];
                delete object[objectName];
                object[this.extraElementData.name] = root;
            }
        }
        this.validate(xmlUtil.jsonToXml(object));
    };
    XMLSchemaObject.prototype.collectReferences = function (xmlString, context, references) {
        var _this = this;
        var doc;
        doc = new DOMParser().parseFromString(xmlString);
        var schema = elementChildrenByName(doc, 'schema', this.namspacePrefix)[0];
        var imports = elementChildrenByName(schema, 'import', this.namspacePrefix);
        var includes = elementChildrenByName(schema, 'include', this.namspacePrefix);
        var refElements = imports.concat(includes);
        refElements.forEach(function (refElement) {
            var refString = refElement.getAttribute('schemaLocation');
            if (refString) {
                var fullPath = _this.provider.resolvePath(context, refString);
                var reference = references[fullPath];
                if (!reference) {
                    var index = Object.keys(references).length;
                    var loadedContent = _this.provider.content(fullPath);
                    var patchedContent;
                    try {
                        patchedContent = _this.collectReferences(loadedContent, fullPath, references);
                    }
                    catch (exception) {
                        patchedContent = loadedContent;
                    }
                    reference = new raml_xml_validation_2.XMLSchemaReference(fullPath, index, patchedContent);
                    references[fullPath] = reference;
                }
                refElement.setAttribute('schemaLocation', "file_" + reference.virtualIndex + ".xsd");
            }
        });
        return doc.toString();
    };
    XMLSchemaObject.prototype.getMissingReferences = function () {
        var _this = this;
        var doc;
        doc = new DOMParser().parseFromString(this.schemaString);
        var schema = elementChildrenByName(doc, 'schema', this.namspacePrefix)[0];
        var imports = elementChildrenByName(schema, 'import', this.namspacePrefix);
        var includes = elementChildrenByName(schema, 'include', this.namspacePrefix);
        var refElements = imports.concat(includes);
        var result = [];
        refElements.forEach(function (refElement) {
            var refString = refElement.getAttribute('schemaLocation');
            if (refString) {
                var fullPath = _this.provider.resolvePath(_this.provider.contextPath(), refString);
                result.push(fullPath);
            }
        });
        return result;
    };
    XMLSchemaObject.prototype.collectReferencesAsync = function (xmlString, context, references) {
        var _this = this;
        var doc;
        doc = new DOMParser().parseFromString(xmlString);
        var schema = elementChildrenByName(doc, 'schema', this.namspacePrefix)[0];
        var imports = elementChildrenByName(schema, 'import', this.namspacePrefix);
        var includes = elementChildrenByName(schema, 'include', this.namspacePrefix);
        var refElements = imports.concat(includes);
        return Promise.all(refElements.map(function (refElement) {
            var refString = refElement.getAttribute('schemaLocation');
            if (refString) {
                var fullPath = _this.provider.resolvePath(context, refString);
                var reference = references[fullPath];
                if (reference) {
                    refElement.setAttribute('schemaLocation', "file_" + reference.virtualIndex + ".xsd");
                    return {};
                }
                return _this.provider.contentAsync(fullPath).then(function (loadedContent) {
                    return _this.collectReferencesAsync(loadedContent, fullPath, references).then(function (patchedContent) {
                        return patchedContent;
                    }, function (reject) { return loadedContent; }).then(function (patchedContent) {
                        var index = Object.keys(references).length;
                        reference = new raml_xml_validation_2.XMLSchemaReference(fullPath, index, patchedContent);
                        references[fullPath] = reference;
                        refElement.setAttribute('schemaLocation', "file_" + reference.virtualIndex + ".xsd");
                        return {};
                    });
                });
            }
            return {};
        })).then(function (resolve) { return Promise.resolve(doc.toString()); });
    };
    XMLSchemaObject.prototype.loadSchemaReferencesAsync = function () {
        return this.collectReferencesAsync(this.schemaString, this.provider.contextPath(), {});
    };
    XMLSchemaObject.prototype.validate = function (xml) {
        try {
            var rs = this.contentToResult[xml];
            if (rs === false) {
                return;
            }
            if (rs) {
                throw rs;
            }
            var references = {};
            var patchedSchema = this.collectReferences(this.schemaString, this.provider.contextPath(), references);
            var validator = new raml_xml_validation_1.XMLValidator(patchedSchema);
            if (this.provider.hasAsyncRequests()) {
                return;
            }
            var validationErrors = validator.validate(xml, Object.keys(references).map(function (key) { return references[key]; }));
            this.acceptErrors("key", validationErrors, true);
            this.contentToResult[xml] = false;
            if (Object.keys(this.contentToResult).length > MAX_EXAMPLES_TRESHOLD) {
                this.contentToResult = {};
            }
        }
        catch (e) {
            this.contentToResult[xml] = e;
            throw e;
        }
    };
    XMLSchemaObject.prototype.handleReferenceElement = function (content) {
        var doc = new DOMParser().parseFromString(content);
        this.namspacePrefix = extractNamespace(doc);
        var schema = elementChildrenByName(doc, 'schema', this.namspacePrefix)[0];
        var elements = elementChildrenByName(schema, 'element', this.namspacePrefix);
        var element = _.find(elements, function (element) { return element.getAttribute('extraelement') === 'true'; });
        if (!element) {
            return content;
        }
        var extraElementData = {};
        extraElementData.name = element.getAttribute('name');
        extraElementData.type = element.getAttribute('type');
        extraElementData.originalName = element.getAttribute('originalname');
        extraElementData.requestedName = element.getAttribute('requestedname');
        if (!extraElementData.type) {
            schema.removeChild(element);
        }
        element.removeAttribute('originalname');
        element.removeAttribute('requestedname');
        element.removeAttribute('extraelement');
        this.extraElementData = extraElementData;
        return doc.toString();
    };
    XMLSchemaObject.prototype.acceptErrors = function (key, errors, throwImmediately) {
        if (throwImmediately === void 0) { throwImmediately = false; }
        if (errors && errors.length > 0) {
            var msg = errors.map(function (x) { return x.message; }).join(", ");
            var res = new ts.ValidationError(typesystem_1.messageRegistry.CONTENT_DOES_NOT_MATCH_THE_SCHEMA, { msg: msg });
            res.errors = errors;
            globalCache.setValue(key, res);
            if (throwImmediately) {
                throw res;
            }
            return;
        }
    };
    return XMLSchemaObject;
}());
exports.XMLSchemaObject = XMLSchemaObject;
function getJSONSchema(content, provider) {
    var key = schemaKey(provider, content);
    var rs = useLint ? globalCache.getValue(key) : false;
    if (rs && rs.provider) {
        return rs;
    }
    var res = new JSONSchemaObject(content, provider);
    globalCache.setValue(key, res);
    return res;
}
exports.getJSONSchema = getJSONSchema;
var schemaKey = function (provider, content) {
    var contextPath = "";
    if (provider) {
        contextPath = provider.contextPath();
    }
    var key = "__SCHEMA_" + content + contextPath;
    return key;
};
function getXMLSchema(content, provider) {
    var key = schemaKey(provider, content);
    var rs = useLint ? globalCache.getValue(content) : false;
    if (rs) {
        return rs;
    }
    var res = new XMLSchemaObject(content, provider);
    if (useLint) {
        globalCache.setValue(content, res);
    }
    return res;
}
exports.getXMLSchema = getXMLSchema;
function createSchema(content, provider) {
    var key = schemaKey(provider, content);
    var rs = useLint ? globalCache.getValue(key) : false;
    if (rs) {
        return rs;
    }
    try {
        var res = new JSONSchemaObject(content, provider);
        if (useLint) {
            globalCache.setValue(key, res);
        }
        return res;
    }
    catch (e) {
        try {
            var res = new XMLSchemaObject(content, provider);
            if (useLint) {
                globalCache.setValue(key, res);
            }
            return res;
        }
        catch (e) {
            if (useLint) {
                globalCache.setValue(key, new ts.ValidationError(typesystem_1.messageRegistry.CAN_NOT_PARSE_SCHEMA));
            }
            return null;
        }
    }
}
exports.createSchema = createSchema;
function elementChildrenByName(parent, tagName, ns) {
    if (ns == null) {
        ns = extractNamespace(parent);
    }
    if (ns.length > 0) {
        ns += ":";
    }
    var elements = parent.getElementsByTagName(ns + tagName);
    var result = [];
    for (var i = 0; i < elements.length; i++) {
        var child = elements[i];
        if (child.parentNode === parent) {
            result.push(child);
        }
    }
    return result;
}
function extractNamespace(documentOrElement) {
    var ns = "";
    if (documentOrElement) {
        var doc = documentOrElement;
        if (documentOrElement.ownerDocument) {
            doc = documentOrElement.ownerDocument;
        }
        if (doc) {
            var docElement = doc.documentElement;
            if (docElement) {
                ns = docElement.prefix;
            }
        }
    }
    return ns;
}
//# sourceMappingURL=schemaUtil.js.map